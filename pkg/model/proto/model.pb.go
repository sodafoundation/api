// Code generated by protoc-gen-go. DO NOT EDIT.
// source: model.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	model.proto

It has these top-level messages:
	CreateVolumeOpts
	DeleteVolumeOpts
	ExtendVolumeOpts
	CreateVolumeSnapshotOpts
	DeleteVolumeSnapshotOpts
	CreateVolumeAttachmentOpts
	DeleteVolumeAttachmentOpts
	CreateSnapshotAttachmentOpts
	DeleteSnapshotAttachmentOpts
	HostInfo
	VolumeData
	CreateReplicationOpts
	DeleteReplicationOpts
	EnableReplicationOpts
	DisableReplicationOpts
	FailoverReplicationOpts
	CreateVolumeGroupOpts
	UpdateVolumeGroupOpts
	DeleteVolumeGroupOpts
	AttachVolumeOpts
	DetachVolumeOpts
	GenericResponse
	GetMetricsOpts
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

// CreateVolumeOpts is a structure which indicates all required properties
// for creating a volume.
type CreateVolumeOpts struct {
	// The uuid of the volume, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the volume, required.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The requested capacity of the volume, required.
	Size int64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// The description of the volume, optional.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// When create volume from snapshot, this field is required.
	SnapshotId string `protobuf:"bytes,5,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// The locality that volume belongs to, required.
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the volume, optional.
	Metadata map[string]string `protobuf:"bytes,10,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,11,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,12,opt,name=context" json:"context,omitempty"`
	// The replication driver data
	ReplicationDriverData map[string]string `protobuf:"bytes,13,rep,name=replicationDriverData" json:"replicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The uuid of replication
	ReplicationId string `protobuf:"bytes,14,opt,name=replicationId" json:"replicationId,omitempty"`
	// The size of snapshot
	SnapshotSize int64 `protobuf:"varint,15,opt,name=snapshotSize" json:"snapshotSize,omitempty"`
	// Down load snapshot from cloud
	SnapshotFromCloud bool `protobuf:"varint,16,opt,name=snapshotFromCloud" json:"snapshotFromCloud,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,17,opt,name=profile" json:"profile,omitempty"`
}

func (m *CreateVolumeOpts) Reset()                    { *m = CreateVolumeOpts{} }
func (m *CreateVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateVolumeOpts) ProtoMessage()               {}
func (*CreateVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CreateVolumeOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateVolumeOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateVolumeOpts) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *CreateVolumeOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateVolumeOpts) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *CreateVolumeOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *CreateVolumeOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *CreateVolumeOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *CreateVolumeOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *CreateVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateVolumeOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateVolumeOpts) GetReplicationDriverData() map[string]string {
	if m != nil {
		return m.ReplicationDriverData
	}
	return nil
}

func (m *CreateVolumeOpts) GetReplicationId() string {
	if m != nil {
		return m.ReplicationId
	}
	return ""
}

func (m *CreateVolumeOpts) GetSnapshotSize() int64 {
	if m != nil {
		return m.SnapshotSize
	}
	return 0
}

func (m *CreateVolumeOpts) GetSnapshotFromCloud() bool {
	if m != nil {
		return m.SnapshotFromCloud
	}
	return false
}

func (m *CreateVolumeOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// DeleteVolumeOpts is a structure which indicates all required properties
// for deleting a volume.
type DeleteVolumeOpts struct {
	// The uuid of the volume, required.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The service level that volume belongs to, required.
	// This item will be replace by profile, don't use it.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,2,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,3,opt,name=poolId" json:"poolId,omitempty"`
	// The metadata of the volume, optional.
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,5,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,6,opt,name=context" json:"context,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,7,opt,name=profile" json:"profile,omitempty"`
}

func (m *DeleteVolumeOpts) Reset()                    { *m = DeleteVolumeOpts{} }
func (m *DeleteVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteVolumeOpts) ProtoMessage()               {}
func (*DeleteVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DeleteVolumeOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteVolumeOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *DeleteVolumeOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *DeleteVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteVolumeOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *DeleteVolumeOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// ExtendVolumeOpts is a structure which indicates all required properties
// for Extending a volume.
type ExtendVolumeOpts struct {
	// The uuid of the volume, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the volume, required.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The requested capacity of the volume, required.
	Size int64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// The description of the volume, optional.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// When create volume from snapshot, this field is required.
	SnapshotId string `protobuf:"bytes,5,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// The locality that volume belongs to, required.
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the volume, optional.
	Metadata map[string]string `protobuf:"bytes,10,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,11,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,12,opt,name=context" json:"context,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,13,opt,name=profile" json:"profile,omitempty"`
}

func (m *ExtendVolumeOpts) Reset()                    { *m = ExtendVolumeOpts{} }
func (m *ExtendVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*ExtendVolumeOpts) ProtoMessage()               {}
func (*ExtendVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ExtendVolumeOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ExtendVolumeOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExtendVolumeOpts) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ExtendVolumeOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ExtendVolumeOpts) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *ExtendVolumeOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *ExtendVolumeOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *ExtendVolumeOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *ExtendVolumeOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *ExtendVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ExtendVolumeOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *ExtendVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *ExtendVolumeOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// CreateVolumeSnapshotOpts is a structure which indicates all required
// properties for creating a volume snapshot.
type CreateVolumeSnapshotOpts struct {
	// The uuid of the volume snapshot, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the volume snapshot, required.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The size of the volume that snapshot belongs to, required.
	Size int64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// The description of the volume snapshot, optional.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// The uuid of the volume that snapshot belongs to, required.
	VolumeId string `protobuf:"bytes,5,opt,name=volumeId" json:"volumeId,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,6,opt,name=profileId" json:"profileId,omitempty"`
	// The metadata of the volume snapshot, optional.
	Metadata map[string]string `protobuf:"bytes,7,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,8,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,9,opt,name=context" json:"context,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,10,opt,name=profile" json:"profile,omitempty"`
}

func (m *CreateVolumeSnapshotOpts) Reset()                    { *m = CreateVolumeSnapshotOpts{} }
func (m *CreateVolumeSnapshotOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateVolumeSnapshotOpts) ProtoMessage()               {}
func (*CreateVolumeSnapshotOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateVolumeSnapshotOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *CreateVolumeSnapshotOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateVolumeSnapshotOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateVolumeSnapshotOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// DeleteVolumeSnapshotOpts is a structure which indicates all required
// properties for deleting a volume snapshot.
type DeleteVolumeSnapshotOpts struct {
	// The uuid of the volume snapshot, required.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the volume that snapshot belongs to, required.
	VolumeId string `protobuf:"bytes,2,opt,name=volumeId" json:"volumeId,omitempty"`
	// The metadata of the volume snapshot, optional.
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,4,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,5,opt,name=context" json:"context,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,6,opt,name=profile" json:"profile,omitempty"`
}

func (m *DeleteVolumeSnapshotOpts) Reset()                    { *m = DeleteVolumeSnapshotOpts{} }
func (m *DeleteVolumeSnapshotOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteVolumeSnapshotOpts) ProtoMessage()               {}
func (*DeleteVolumeSnapshotOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DeleteVolumeSnapshotOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteVolumeSnapshotOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *DeleteVolumeSnapshotOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// CreateVolumeAttachmentOpts is a structure which indicates all required
// properties for creating a volume attachment.
type CreateVolumeAttachmentOpts struct {
	// The uuid of the volume attachment, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the volume, required.
	VolumeId string `protobuf:"bytes,2,opt,name=volumeId" json:"volumeId,omitempty"`
	// This field indicates if the volume is attached locally, optional.
	DoLocalAttach bool `protobuf:"varint,3,opt,name=doLocalAttach" json:"doLocalAttach,omitempty"`
	// This field indicates if the volume is attached multiple times, optional.
	MultiPath bool `protobuf:"varint,4,opt,name=multiPath" json:"multiPath,omitempty"`
	// The infomation of the host node on which the volume will be attached.
	HostInfo *HostInfo `protobuf:"bytes,5,opt,name=hostInfo" json:"hostInfo,omitempty"`
	// The metadata of the volume attachment, optional.
	Metadata map[string]string `protobuf:"bytes,6,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,7,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,8,opt,name=context" json:"context,omitempty"`
	// The protocol
	AccessProtocol string `protobuf:"bytes,9,opt,name=AccessProtocol" json:"AccessProtocol,omitempty"`
}

func (m *CreateVolumeAttachmentOpts) Reset()                    { *m = CreateVolumeAttachmentOpts{} }
func (m *CreateVolumeAttachmentOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateVolumeAttachmentOpts) ProtoMessage()               {}
func (*CreateVolumeAttachmentOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CreateVolumeAttachmentOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateVolumeAttachmentOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *CreateVolumeAttachmentOpts) GetDoLocalAttach() bool {
	if m != nil {
		return m.DoLocalAttach
	}
	return false
}

func (m *CreateVolumeAttachmentOpts) GetMultiPath() bool {
	if m != nil {
		return m.MultiPath
	}
	return false
}

func (m *CreateVolumeAttachmentOpts) GetHostInfo() *HostInfo {
	if m != nil {
		return m.HostInfo
	}
	return nil
}

func (m *CreateVolumeAttachmentOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateVolumeAttachmentOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateVolumeAttachmentOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateVolumeAttachmentOpts) GetAccessProtocol() string {
	if m != nil {
		return m.AccessProtocol
	}
	return ""
}

// DeleteVolumeAttachmentOpts is a structure which indicates all required
// properties for deleting a volume attachment.
type DeleteVolumeAttachmentOpts struct {
	// The uuid of the volume attachment, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the volume, required.
	VolumeId string `protobuf:"bytes,2,opt,name=volumeId" json:"volumeId,omitempty"`
	// The infomation of the host node on which the volume will be attached.
	HostInfo *HostInfo `protobuf:"bytes,3,opt,name=hostInfo" json:"hostInfo,omitempty"`
	// The metadata of the volume attachment, optional.
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,5,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,6,opt,name=context" json:"context,omitempty"`
	// The protocol
	AccessProtocol string `protobuf:"bytes,7,opt,name=AccessProtocol" json:"AccessProtocol,omitempty"`
}

func (m *DeleteVolumeAttachmentOpts) Reset()                    { *m = DeleteVolumeAttachmentOpts{} }
func (m *DeleteVolumeAttachmentOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteVolumeAttachmentOpts) ProtoMessage()               {}
func (*DeleteVolumeAttachmentOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DeleteVolumeAttachmentOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteVolumeAttachmentOpts) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *DeleteVolumeAttachmentOpts) GetHostInfo() *HostInfo {
	if m != nil {
		return m.HostInfo
	}
	return nil
}

func (m *DeleteVolumeAttachmentOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteVolumeAttachmentOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteVolumeAttachmentOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *DeleteVolumeAttachmentOpts) GetAccessProtocol() string {
	if m != nil {
		return m.AccessProtocol
	}
	return ""
}

// CreateSnapshotAttachmentOpts is a structure which indicates all required
// properties for creating a snapshot attachment.
type CreateSnapshotAttachmentOpts struct {
	// The uuid of the snapshot attachment, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the snapshot, required.
	SnapshotId string `protobuf:"bytes,2,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// This field indicates if the snapshot is attached locally, optional.
	DoLocalAttach bool `protobuf:"varint,3,opt,name=doLocalAttach" json:"doLocalAttach,omitempty"`
	// This field indicates if the snapshot is attached multiple times, optional.
	MultiPath bool `protobuf:"varint,4,opt,name=multiPath" json:"multiPath,omitempty"`
	// The infomation of the host node on which the snapshot will be attached.
	HostInfo *HostInfo `protobuf:"bytes,5,opt,name=hostInfo" json:"hostInfo,omitempty"`
	// The metadata of the snapshot attachment, optional.
	Metadata map[string]string `protobuf:"bytes,6,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,7,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,8,opt,name=context" json:"context,omitempty"`
	// The protocol
	AccessProtocol string `protobuf:"bytes,9,opt,name=AccessProtocol" json:"AccessProtocol,omitempty"`
}

func (m *CreateSnapshotAttachmentOpts) Reset()                    { *m = CreateSnapshotAttachmentOpts{} }
func (m *CreateSnapshotAttachmentOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateSnapshotAttachmentOpts) ProtoMessage()               {}
func (*CreateSnapshotAttachmentOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CreateSnapshotAttachmentOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateSnapshotAttachmentOpts) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *CreateSnapshotAttachmentOpts) GetDoLocalAttach() bool {
	if m != nil {
		return m.DoLocalAttach
	}
	return false
}

func (m *CreateSnapshotAttachmentOpts) GetMultiPath() bool {
	if m != nil {
		return m.MultiPath
	}
	return false
}

func (m *CreateSnapshotAttachmentOpts) GetHostInfo() *HostInfo {
	if m != nil {
		return m.HostInfo
	}
	return nil
}

func (m *CreateSnapshotAttachmentOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateSnapshotAttachmentOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateSnapshotAttachmentOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateSnapshotAttachmentOpts) GetAccessProtocol() string {
	if m != nil {
		return m.AccessProtocol
	}
	return ""
}

// DeleteSnapshotAttachmentOpts is a structure which indicates all required
// properties for deleting a snapshot attachment.
type DeleteSnapshotAttachmentOpts struct {
	// The uuid of the snapshot attachment, optional.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The uuid of the snapshot, required.
	SnapshotId string `protobuf:"bytes,2,opt,name=snapshotId" json:"snapshotId,omitempty"`
	// The infomation of the host node on which the volume will be attached.
	HostInfo *HostInfo `protobuf:"bytes,3,opt,name=hostInfo" json:"hostInfo,omitempty"`
	// The metadata of the snapshot attachment, optional.
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The storage driver type.
	DriverName string `protobuf:"bytes,5,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,6,opt,name=context" json:"context,omitempty"`
	// The protocol
	AccessProtocol string `protobuf:"bytes,7,opt,name=AccessProtocol" json:"AccessProtocol,omitempty"`
}

func (m *DeleteSnapshotAttachmentOpts) Reset()                    { *m = DeleteSnapshotAttachmentOpts{} }
func (m *DeleteSnapshotAttachmentOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteSnapshotAttachmentOpts) ProtoMessage()               {}
func (*DeleteSnapshotAttachmentOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DeleteSnapshotAttachmentOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteSnapshotAttachmentOpts) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *DeleteSnapshotAttachmentOpts) GetHostInfo() *HostInfo {
	if m != nil {
		return m.HostInfo
	}
	return nil
}

func (m *DeleteSnapshotAttachmentOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteSnapshotAttachmentOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteSnapshotAttachmentOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *DeleteSnapshotAttachmentOpts) GetAccessProtocol() string {
	if m != nil {
		return m.AccessProtocol
	}
	return ""
}

type HostInfo struct {
	// The platform of the host, such as "x86_64"
	Platform string `protobuf:"bytes,1,opt,name=platform" json:"platform,omitempty"`
	// The type of OS, such as "linux","windows", etc.
	OsType string `protobuf:"bytes,2,opt,name=osType" json:"osType,omitempty"`
	// The name of the host
	Host string `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	// The ip address of the host
	Ip string `protobuf:"bytes,4,opt,name=ip" json:"ip,omitempty"`
	// The initiator infomation, such as: "iqn.2017.com.redhat:e08039b48d5c"
	Initiator string `protobuf:"bytes,5,opt,name=initiator" json:"initiator,omitempty"`
}

func (m *HostInfo) Reset()                    { *m = HostInfo{} }
func (m *HostInfo) String() string            { return proto1.CompactTextString(m) }
func (*HostInfo) ProtoMessage()               {}
func (*HostInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *HostInfo) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *HostInfo) GetOsType() string {
	if m != nil {
		return m.OsType
	}
	return ""
}

func (m *HostInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HostInfo) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *HostInfo) GetInitiator() string {
	if m != nil {
		return m.Initiator
	}
	return ""
}

type VolumeData struct {
	Data map[string]string `protobuf:"bytes,1,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VolumeData) Reset()                    { *m = VolumeData{} }
func (m *VolumeData) String() string            { return proto1.CompactTextString(m) }
func (*VolumeData) ProtoMessage()               {}
func (*VolumeData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *VolumeData) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

// CreateReplicationOpts is a structure which indicates all required properties
// for creating a replication.
// NOTE: Need to figure out how to handle more than 2 sites.
type CreateReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
	// Whether is primary replication
	IsPrimary bool `protobuf:"varint,16,opt,name=isPrimary" json:"isPrimary,omitempty"`
	// The replication metadata
	Metadata map[string]string `protobuf:"bytes,17,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The volume data list
	VolumeDataList []*VolumeData `protobuf:"bytes,18,rep,name=volumeDataList" json:"volumeDataList,omitempty"`
	// the replication mode sync/async
	ReplicationMode string `protobuf:"bytes,19,opt,name=replicationMode" json:"replicationMode,omitempty"`
	// 0 means sync replication.
	ReplicationPeriod int64 `protobuf:"varint,20,opt,name=ReplicationPeriod" json:"ReplicationPeriod,omitempty"`
	// replication bandwidth
	ReplicationBandwidth int64 `protobuf:"varint,21,opt,name=ReplicationBandwidth" json:"ReplicationBandwidth,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,22,opt,name=profile" json:"profile,omitempty"`
}

func (m *CreateReplicationOpts) Reset()                    { *m = CreateReplicationOpts{} }
func (m *CreateReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateReplicationOpts) ProtoMessage()               {}
func (*CreateReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *CreateReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *CreateReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *CreateReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *CreateReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *CreateReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *CreateReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *CreateReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *CreateReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *CreateReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *CreateReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateReplicationOpts) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *CreateReplicationOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreateReplicationOpts) GetVolumeDataList() []*VolumeData {
	if m != nil {
		return m.VolumeDataList
	}
	return nil
}

func (m *CreateReplicationOpts) GetReplicationMode() string {
	if m != nil {
		return m.ReplicationMode
	}
	return ""
}

func (m *CreateReplicationOpts) GetReplicationPeriod() int64 {
	if m != nil {
		return m.ReplicationPeriod
	}
	return 0
}

func (m *CreateReplicationOpts) GetReplicationBandwidth() int64 {
	if m != nil {
		return m.ReplicationBandwidth
	}
	return 0
}

func (m *CreateReplicationOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// Delete ReplicationOpts is a structure which indicates all required properties
// for deleting a replication.
// NOTE: Need to figure out how to handle more than 2 sites.
type DeleteReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
	// The replication metadata
	Metadata map[string]string `protobuf:"bytes,16,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Whether is primary replication
	IsPrimary bool `protobuf:"varint,17,opt,name=isPrimary" json:"isPrimary,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,18,opt,name=profile" json:"profile,omitempty"`
}

func (m *DeleteReplicationOpts) Reset()                    { *m = DeleteReplicationOpts{} }
func (m *DeleteReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteReplicationOpts) ProtoMessage()               {}
func (*DeleteReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DeleteReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *DeleteReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *DeleteReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *DeleteReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *DeleteReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *DeleteReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *DeleteReplicationOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DeleteReplicationOpts) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *DeleteReplicationOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// Delete ReplicationOpts is a structure which indicates all required properties
type EnableReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
	// The replication metadata
	Metadata map[string]string `protobuf:"bytes,16,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Whether is primary replication
	IsPrimary bool `protobuf:"varint,17,opt,name=isPrimary" json:"isPrimary,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,18,opt,name=profile" json:"profile,omitempty"`
}

func (m *EnableReplicationOpts) Reset()                    { *m = EnableReplicationOpts{} }
func (m *EnableReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*EnableReplicationOpts) ProtoMessage()               {}
func (*EnableReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *EnableReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *EnableReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnableReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *EnableReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *EnableReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *EnableReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *EnableReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *EnableReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *EnableReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *EnableReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *EnableReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *EnableReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *EnableReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *EnableReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *EnableReplicationOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *EnableReplicationOpts) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *EnableReplicationOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// Delete ReplicationOpts is a structure which indicates all required properties
type DisableReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
	// The replication metadata
	Metadata map[string]string `protobuf:"bytes,16,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Whether is primary replication
	IsPrimary bool `protobuf:"varint,17,opt,name=isPrimary" json:"isPrimary,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,18,opt,name=profile" json:"profile,omitempty"`
}

func (m *DisableReplicationOpts) Reset()                    { *m = DisableReplicationOpts{} }
func (m *DisableReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*DisableReplicationOpts) ProtoMessage()               {}
func (*DisableReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *DisableReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DisableReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DisableReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *DisableReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *DisableReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *DisableReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *DisableReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *DisableReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *DisableReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *DisableReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *DisableReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *DisableReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *DisableReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DisableReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *DisableReplicationOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DisableReplicationOpts) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *DisableReplicationOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// Delete ReplicationOpts is a structure which indicates all required properties
type FailoverReplicationOpts struct {
	// The uuid of the replication, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the replication, optional.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The description of the replication, optional.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// The uuid of the primary volume. This field is required.
	PrimaryVolumeId string `protobuf:"bytes,4,opt,name=primaryVolumeId" json:"primaryVolumeId,omitempty"`
	// The uuid of the secondary volume. This field is required.
	SecondaryVolumeId string `protobuf:"bytes,5,opt,name=secondaryVolumeId" json:"secondaryVolumeId,omitempty"`
	// The dock infomation on which the request will be executed
	AvailabilityZone string `protobuf:"bytes,6,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The service level that volume belongs to, required.
	// TODO: This item will be replace by profile, don't use it.
	ProfileId string `protobuf:"bytes,7,opt,name=profileId" json:"profileId,omitempty"`
	// The uuid of the pool on which volume will be created, required.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The name of the pool on which volume will be created, required.
	PoolName string `protobuf:"bytes,9,opt,name=poolName" json:"poolName,omitempty"`
	// The metadata of the primary replication, optional.
	PrimaryReplicationDriverData map[string]string `protobuf:"bytes,11,rep,name=primaryReplicationDriverData" json:"primaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The metadata of the seondary replication, optional.
	SecondaryReplicationDriverData map[string]string `protobuf:"bytes,12,rep,name=secondaryReplicationDriverData" json:"secondaryReplicationDriverData,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The dock id.
	DockId string `protobuf:"bytes,13,opt,name=dockId" json:"dockId,omitempty"`
	// The replication driver type.
	DriverName string `protobuf:"bytes,14,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,15,opt,name=context" json:"context,omitempty"`
	// Allow attached volume
	AllowAttachedVolume bool `protobuf:"varint,16,opt,name=allowAttachedVolume" json:"allowAttachedVolume,omitempty"`
	// The secondary backend id.
	SecondaryBackendId string `protobuf:"bytes,17,opt,name=secondaryBackendId" json:"secondaryBackendId,omitempty"`
	// The replication metadata
	Metadata map[string]string `protobuf:"bytes,18,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Whether is primary replication
	IsPrimary bool `protobuf:"varint,19,opt,name=isPrimary" json:"isPrimary,omitempty"`
	// The Serialized profile
	Profile string `protobuf:"bytes,20,opt,name=profile" json:"profile,omitempty"`
}

func (m *FailoverReplicationOpts) Reset()                    { *m = FailoverReplicationOpts{} }
func (m *FailoverReplicationOpts) String() string            { return proto1.CompactTextString(m) }
func (*FailoverReplicationOpts) ProtoMessage()               {}
func (*FailoverReplicationOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *FailoverReplicationOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FailoverReplicationOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FailoverReplicationOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPrimaryVolumeId() string {
	if m != nil {
		return m.PrimaryVolumeId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetSecondaryVolumeId() string {
	if m != nil {
		return m.SecondaryVolumeId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *FailoverReplicationOpts) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *FailoverReplicationOpts) GetPrimaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.PrimaryReplicationDriverData
	}
	return nil
}

func (m *FailoverReplicationOpts) GetSecondaryReplicationDriverData() map[string]string {
	if m != nil {
		return m.SecondaryReplicationDriverData
	}
	return nil
}

func (m *FailoverReplicationOpts) GetDockId() string {
	if m != nil {
		return m.DockId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *FailoverReplicationOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *FailoverReplicationOpts) GetAllowAttachedVolume() bool {
	if m != nil {
		return m.AllowAttachedVolume
	}
	return false
}

func (m *FailoverReplicationOpts) GetSecondaryBackendId() string {
	if m != nil {
		return m.SecondaryBackendId
	}
	return ""
}

func (m *FailoverReplicationOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *FailoverReplicationOpts) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *FailoverReplicationOpts) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

type FailoverReplicationOpts_FailoverRequest struct {
	AllowAttachedVolume bool   `protobuf:"varint,1,opt,name=allowAttachedVolume" json:"allowAttachedVolume,omitempty"`
	SecondaryBackendId  string `protobuf:"bytes,2,opt,name=secondaryBackendId" json:"secondaryBackendId,omitempty"`
}

func (m *FailoverReplicationOpts_FailoverRequest) Reset() {
	*m = FailoverReplicationOpts_FailoverRequest{}
}
func (m *FailoverReplicationOpts_FailoverRequest) String() string { return proto1.CompactTextString(m) }
func (*FailoverReplicationOpts_FailoverRequest) ProtoMessage()    {}
func (*FailoverReplicationOpts_FailoverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 3}
}

func (m *FailoverReplicationOpts_FailoverRequest) GetAllowAttachedVolume() bool {
	if m != nil {
		return m.AllowAttachedVolume
	}
	return false
}

func (m *FailoverReplicationOpts_FailoverRequest) GetSecondaryBackendId() string {
	if m != nil {
		return m.SecondaryBackendId
	}
	return ""
}

// CreateVolumeGroupOpts is a structure which indicates all required
// properties for creating a volume group.
type CreateVolumeGroupOpts struct {
	// The uuid of the volume group, optional when creating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The name of the volume, required.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The driver of the volume group.
	DriverName string `protobuf:"bytes,3,opt,name=driverName" json:"driverName,omitempty"`
	// The description of the volume, optional.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	// When create volume from snapshot, this field is required.
	AvailabilityZone string `protobuf:"bytes,5,opt,name=availabilityZone" json:"availabilityZone,omitempty"`
	// The addVolumes contain UUIDs of volumes to be added to the group.
	AddVolumes []string `protobuf:"bytes,6,rep,name=addVolumes" json:"addVolumes,omitempty"`
	// The removeVolumes contains the volumes to be removed from the group.
	RemoveVolumes []string `protobuf:"bytes,7,rep,name=removeVolumes" json:"removeVolumes,omitempty"`
	// The pool belongs to the group.
	PoolId string `protobuf:"bytes,8,opt,name=poolId" json:"poolId,omitempty"`
	// The Context
	Context string `protobuf:"bytes,9,opt,name=context" json:"context,omitempty"`
}

func (m *CreateVolumeGroupOpts) Reset()                    { *m = CreateVolumeGroupOpts{} }
func (m *CreateVolumeGroupOpts) String() string            { return proto1.CompactTextString(m) }
func (*CreateVolumeGroupOpts) ProtoMessage()               {}
func (*CreateVolumeGroupOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CreateVolumeGroupOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CreateVolumeGroupOpts) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateVolumeGroupOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *CreateVolumeGroupOpts) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateVolumeGroupOpts) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *CreateVolumeGroupOpts) GetAddVolumes() []string {
	if m != nil {
		return m.AddVolumes
	}
	return nil
}

func (m *CreateVolumeGroupOpts) GetRemoveVolumes() []string {
	if m != nil {
		return m.RemoveVolumes
	}
	return nil
}

func (m *CreateVolumeGroupOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *CreateVolumeGroupOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

type UpdateVolumeGroupOpts struct {
	// The uuid of the volume group, optional when updating.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The driver of the volume group.
	DriverName string `protobuf:"bytes,2,opt,name=driverName" json:"driverName,omitempty"`
	// The addVolumes contain UUIDs of volumes to be added to the group.
	AddVolumes []string `protobuf:"bytes,3,rep,name=addVolumes" json:"addVolumes,omitempty"`
	// The removeVolumes contains the volumes to be removed from the group.
	RemoveVolumes []string `protobuf:"bytes,4,rep,name=removeVolumes" json:"removeVolumes,omitempty"`
	// The pool belongs to the group.
	PoolId string `protobuf:"bytes,5,opt,name=poolId" json:"poolId,omitempty"`
	// The Context
	Context string `protobuf:"bytes,6,opt,name=context" json:"context,omitempty"`
}

func (m *UpdateVolumeGroupOpts) Reset()                    { *m = UpdateVolumeGroupOpts{} }
func (m *UpdateVolumeGroupOpts) String() string            { return proto1.CompactTextString(m) }
func (*UpdateVolumeGroupOpts) ProtoMessage()               {}
func (*UpdateVolumeGroupOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *UpdateVolumeGroupOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateVolumeGroupOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *UpdateVolumeGroupOpts) GetAddVolumes() []string {
	if m != nil {
		return m.AddVolumes
	}
	return nil
}

func (m *UpdateVolumeGroupOpts) GetRemoveVolumes() []string {
	if m != nil {
		return m.RemoveVolumes
	}
	return nil
}

func (m *UpdateVolumeGroupOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *UpdateVolumeGroupOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

type DeleteVolumeGroupOpts struct {
	// The uuid of the volume group, optional when deleting.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The pool belongs to the group.
	PoolId string `protobuf:"bytes,2,opt,name=poolId" json:"poolId,omitempty"`
	// The driver of the volume group.
	DriverName string `protobuf:"bytes,3,opt,name=driverName" json:"driverName,omitempty"`
	// The Context
	Context string `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
}

func (m *DeleteVolumeGroupOpts) Reset()                    { *m = DeleteVolumeGroupOpts{} }
func (m *DeleteVolumeGroupOpts) String() string            { return proto1.CompactTextString(m) }
func (*DeleteVolumeGroupOpts) ProtoMessage()               {}
func (*DeleteVolumeGroupOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DeleteVolumeGroupOpts) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteVolumeGroupOpts) GetPoolId() string {
	if m != nil {
		return m.PoolId
	}
	return ""
}

func (m *DeleteVolumeGroupOpts) GetDriverName() string {
	if m != nil {
		return m.DriverName
	}
	return ""
}

func (m *DeleteVolumeGroupOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// AttachVolumeOpts is a structure which indicates all required
// properties for attaching a volume.
type AttachVolumeOpts struct {
	// The access protocol for attaching a volume.
	AccessProtocol string `protobuf:"bytes,1,opt,name=accessProtocol" json:"accessProtocol,omitempty"`
	// The connectionData for attaching a volume.
	ConnectionData string `protobuf:"bytes,2,opt,name=connectionData" json:"connectionData,omitempty"`
	// The metadata for attaching a volume, optional.
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The Context
	Context string `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
}

func (m *AttachVolumeOpts) Reset()                    { *m = AttachVolumeOpts{} }
func (m *AttachVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*AttachVolumeOpts) ProtoMessage()               {}
func (*AttachVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *AttachVolumeOpts) GetAccessProtocol() string {
	if m != nil {
		return m.AccessProtocol
	}
	return ""
}

func (m *AttachVolumeOpts) GetConnectionData() string {
	if m != nil {
		return m.ConnectionData
	}
	return ""
}

func (m *AttachVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *AttachVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// DetachVolumeOpts is a structure which indicates all required
// properties for detaching a volume.
type DetachVolumeOpts struct {
	// The access protocol for detaching a volume.
	AccessProtocol string `protobuf:"bytes,1,opt,name=accessProtocol" json:"accessProtocol,omitempty"`
	// The connectionData for detaching a volume.
	ConnectionData string `protobuf:"bytes,2,opt,name=connectionData" json:"connectionData,omitempty"`
	// The metadata for detaching a volume, optional.
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The Context
	Context string `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
}

func (m *DetachVolumeOpts) Reset()                    { *m = DetachVolumeOpts{} }
func (m *DetachVolumeOpts) String() string            { return proto1.CompactTextString(m) }
func (*DetachVolumeOpts) ProtoMessage()               {}
func (*DetachVolumeOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DetachVolumeOpts) GetAccessProtocol() string {
	if m != nil {
		return m.AccessProtocol
	}
	return ""
}

func (m *DetachVolumeOpts) GetConnectionData() string {
	if m != nil {
		return m.ConnectionData
	}
	return ""
}

func (m *DetachVolumeOpts) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DetachVolumeOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// Generic response, it return:
// 1. Return result with message when create/update resource successfully.
// 2. Return result without message when delete resource successfully.
// 3. Return Error with error code and message when operate unsuccessfully.
type GenericResponse struct {
	// Types that are valid to be assigned to Reply:
	//	*GenericResponse_Result_
	//	*GenericResponse_Error_
	Reply isGenericResponse_Reply `protobuf_oneof:"reply"`
}

func (m *GenericResponse) Reset()                    { *m = GenericResponse{} }
func (m *GenericResponse) String() string            { return proto1.CompactTextString(m) }
func (*GenericResponse) ProtoMessage()               {}
func (*GenericResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type isGenericResponse_Reply interface {
	isGenericResponse_Reply()
}

type GenericResponse_Result_ struct {
	Result *GenericResponse_Result `protobuf:"bytes,1,opt,name=result,oneof"`
}
type GenericResponse_Error_ struct {
	Error *GenericResponse_Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*GenericResponse_Result_) isGenericResponse_Reply() {}
func (*GenericResponse_Error_) isGenericResponse_Reply()  {}

func (m *GenericResponse) GetReply() isGenericResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *GenericResponse) GetResult() *GenericResponse_Result {
	if x, ok := m.GetReply().(*GenericResponse_Result_); ok {
		return x.Result
	}
	return nil
}

func (m *GenericResponse) GetError() *GenericResponse_Error {
	if x, ok := m.GetReply().(*GenericResponse_Error_); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GenericResponse) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _GenericResponse_OneofMarshaler, _GenericResponse_OneofUnmarshaler, _GenericResponse_OneofSizer, []interface{}{
		(*GenericResponse_Result_)(nil),
		(*GenericResponse_Error_)(nil),
	}
}

func _GenericResponse_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*GenericResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GenericResponse_Result_:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *GenericResponse_Error_:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GenericResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _GenericResponse_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*GenericResponse)
	switch tag {
	case 1: // reply.result
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(GenericResponse_Result)
		err := b.DecodeMessage(msg)
		m.Reply = &GenericResponse_Result_{msg}
		return true, err
	case 2: // reply.error
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(GenericResponse_Error)
		err := b.DecodeMessage(msg)
		m.Reply = &GenericResponse_Error_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GenericResponse_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*GenericResponse)
	// reply
	switch x := m.Reply.(type) {
	case *GenericResponse_Result_:
		s := proto1.Size(x.Result)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *GenericResponse_Error_:
		s := proto1.Size(x.Error)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GenericResponse_Result struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *GenericResponse_Result) Reset()                    { *m = GenericResponse_Result{} }
func (m *GenericResponse_Result) String() string            { return proto1.CompactTextString(m) }
func (*GenericResponse_Result) ProtoMessage()               {}
func (*GenericResponse_Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 0} }

func (m *GenericResponse_Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GenericResponse_Error struct {
	Code        string `protobuf:"bytes,1,opt,name=code" json:"code,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *GenericResponse_Error) Reset()                    { *m = GenericResponse_Error{} }
func (m *GenericResponse_Error) String() string            { return proto1.CompactTextString(m) }
func (*GenericResponse_Error) ProtoMessage()               {}
func (*GenericResponse_Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 1} }

func (m *GenericResponse_Error) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *GenericResponse_Error) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type GetMetricsOpts struct {
	InstanceId string `protobuf:"bytes,1,opt,name=instanceId" json:"instanceId,omitempty"`
	MetricName string `protobuf:"bytes,2,opt,name=metricName" json:"metricName,omitempty"`
	StartTime  string `protobuf:"bytes,3,opt,name=startTime" json:"startTime,omitempty"`
	EndTime    string `protobuf:"bytes,4,opt,name=endTime" json:"endTime,omitempty"`
	Context    string `protobuf:"bytes,5,opt,name=context" json:"context,omitempty"`
}

func (m *GetMetricsOpts) Reset()                    { *m = GetMetricsOpts{} }
func (m *GetMetricsOpts) String() string            { return proto1.CompactTextString(m) }
func (*GetMetricsOpts) ProtoMessage()               {}
func (*GetMetricsOpts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *GetMetricsOpts) GetInstanceId() string {
	if m != nil {
		return m.InstanceId
	}
	return ""
}

func (m *GetMetricsOpts) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *GetMetricsOpts) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *GetMetricsOpts) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *GetMetricsOpts) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func init() {
	proto1.RegisterType((*CreateVolumeOpts)(nil), "proto.CreateVolumeOpts")
	proto1.RegisterType((*DeleteVolumeOpts)(nil), "proto.DeleteVolumeOpts")
	proto1.RegisterType((*ExtendVolumeOpts)(nil), "proto.ExtendVolumeOpts")
	proto1.RegisterType((*CreateVolumeSnapshotOpts)(nil), "proto.CreateVolumeSnapshotOpts")
	proto1.RegisterType((*DeleteVolumeSnapshotOpts)(nil), "proto.DeleteVolumeSnapshotOpts")
	proto1.RegisterType((*CreateVolumeAttachmentOpts)(nil), "proto.CreateVolumeAttachmentOpts")
	proto1.RegisterType((*DeleteVolumeAttachmentOpts)(nil), "proto.DeleteVolumeAttachmentOpts")
	proto1.RegisterType((*CreateSnapshotAttachmentOpts)(nil), "proto.CreateSnapshotAttachmentOpts")
	proto1.RegisterType((*DeleteSnapshotAttachmentOpts)(nil), "proto.DeleteSnapshotAttachmentOpts")
	proto1.RegisterType((*HostInfo)(nil), "proto.HostInfo")
	proto1.RegisterType((*VolumeData)(nil), "proto.VolumeData")
	proto1.RegisterType((*CreateReplicationOpts)(nil), "proto.CreateReplicationOpts")
	proto1.RegisterType((*DeleteReplicationOpts)(nil), "proto.DeleteReplicationOpts")
	proto1.RegisterType((*EnableReplicationOpts)(nil), "proto.EnableReplicationOpts")
	proto1.RegisterType((*DisableReplicationOpts)(nil), "proto.DisableReplicationOpts")
	proto1.RegisterType((*FailoverReplicationOpts)(nil), "proto.FailoverReplicationOpts")
	proto1.RegisterType((*FailoverReplicationOpts_FailoverRequest)(nil), "proto.FailoverReplicationOpts.FailoverRequest")
	proto1.RegisterType((*CreateVolumeGroupOpts)(nil), "proto.CreateVolumeGroupOpts")
	proto1.RegisterType((*UpdateVolumeGroupOpts)(nil), "proto.UpdateVolumeGroupOpts")
	proto1.RegisterType((*DeleteVolumeGroupOpts)(nil), "proto.DeleteVolumeGroupOpts")
	proto1.RegisterType((*AttachVolumeOpts)(nil), "proto.AttachVolumeOpts")
	proto1.RegisterType((*DetachVolumeOpts)(nil), "proto.DetachVolumeOpts")
	proto1.RegisterType((*GenericResponse)(nil), "proto.GenericResponse")
	proto1.RegisterType((*GenericResponse_Result)(nil), "proto.GenericResponse.Result")
	proto1.RegisterType((*GenericResponse_Error)(nil), "proto.GenericResponse.Error")
	proto1.RegisterType((*GetMetricsOpts)(nil), "proto.GetMetricsOpts")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Controller service

type ControllerClient interface {
	// Create a volume
	CreateVolume(ctx context.Context, in *CreateVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume
	DeleteVolume(ctx context.Context, in *DeleteVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Extend a volume
	ExtendVolume(ctx context.Context, in *ExtendVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume snapshot
	CreateVolumeSnapshot(ctx context.Context, in *CreateVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume snapshot
	DeleteVolumeSnapshot(ctx context.Context, in *DeleteVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume attachment
	CreateVolumeAttachment(ctx context.Context, in *CreateVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume attachment
	DeleteVolumeAttachment(ctx context.Context, in *DeleteVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a replication
	CreateReplication(ctx context.Context, in *CreateReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a replication
	DeleteReplication(ctx context.Context, in *DeleteReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Enable a replication
	EnableReplication(ctx context.Context, in *EnableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Disable a replication
	DisableReplication(ctx context.Context, in *DisableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Failover a replication
	FailoverReplication(ctx context.Context, in *FailoverReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume group
	CreateVolumeGroup(ctx context.Context, in *CreateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Update volume group
	UpdateVolumeGroup(ctx context.Context, in *UpdateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete volume group
	DeleteVolumeGroup(ctx context.Context, in *DeleteVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	GetMetrics(ctx context.Context, in *GetMetricsOpts, opts ...grpc.CallOption) (*GenericResponse, error)
}

type controllerClient struct {
	cc *grpc.ClientConn
}

func NewControllerClient(cc *grpc.ClientConn) ControllerClient {
	return &controllerClient{cc}
}

func (c *controllerClient) CreateVolume(ctx context.Context, in *CreateVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/CreateVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) DeleteVolume(ctx context.Context, in *DeleteVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/DeleteVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ExtendVolume(ctx context.Context, in *ExtendVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/ExtendVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) CreateVolumeSnapshot(ctx context.Context, in *CreateVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/CreateVolumeSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) DeleteVolumeSnapshot(ctx context.Context, in *DeleteVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/DeleteVolumeSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) CreateVolumeAttachment(ctx context.Context, in *CreateVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/CreateVolumeAttachment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) DeleteVolumeAttachment(ctx context.Context, in *DeleteVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/DeleteVolumeAttachment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) CreateReplication(ctx context.Context, in *CreateReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/CreateReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) DeleteReplication(ctx context.Context, in *DeleteReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/DeleteReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) EnableReplication(ctx context.Context, in *EnableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/EnableReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) DisableReplication(ctx context.Context, in *DisableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/DisableReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) FailoverReplication(ctx context.Context, in *FailoverReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/FailoverReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) CreateVolumeGroup(ctx context.Context, in *CreateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/CreateVolumeGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) UpdateVolumeGroup(ctx context.Context, in *UpdateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/UpdateVolumeGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) DeleteVolumeGroup(ctx context.Context, in *DeleteVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/DeleteVolumeGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) GetMetrics(ctx context.Context, in *GetMetricsOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.Controller/GetMetrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Controller service

type ControllerServer interface {
	// Create a volume
	CreateVolume(context.Context, *CreateVolumeOpts) (*GenericResponse, error)
	// Delete a volume
	DeleteVolume(context.Context, *DeleteVolumeOpts) (*GenericResponse, error)
	// Extend a volume
	ExtendVolume(context.Context, *ExtendVolumeOpts) (*GenericResponse, error)
	// Create a volume snapshot
	CreateVolumeSnapshot(context.Context, *CreateVolumeSnapshotOpts) (*GenericResponse, error)
	// Delete a volume snapshot
	DeleteVolumeSnapshot(context.Context, *DeleteVolumeSnapshotOpts) (*GenericResponse, error)
	// Create a volume attachment
	CreateVolumeAttachment(context.Context, *CreateVolumeAttachmentOpts) (*GenericResponse, error)
	// Delete a volume attachment
	DeleteVolumeAttachment(context.Context, *DeleteVolumeAttachmentOpts) (*GenericResponse, error)
	// Create a replication
	CreateReplication(context.Context, *CreateReplicationOpts) (*GenericResponse, error)
	// Delete a replication
	DeleteReplication(context.Context, *DeleteReplicationOpts) (*GenericResponse, error)
	// Enable a replication
	EnableReplication(context.Context, *EnableReplicationOpts) (*GenericResponse, error)
	// Disable a replication
	DisableReplication(context.Context, *DisableReplicationOpts) (*GenericResponse, error)
	// Failover a replication
	FailoverReplication(context.Context, *FailoverReplicationOpts) (*GenericResponse, error)
	// Create a volume group
	CreateVolumeGroup(context.Context, *CreateVolumeGroupOpts) (*GenericResponse, error)
	// Update volume group
	UpdateVolumeGroup(context.Context, *UpdateVolumeGroupOpts) (*GenericResponse, error)
	// Delete volume group
	DeleteVolumeGroup(context.Context, *DeleteVolumeGroupOpts) (*GenericResponse, error)
	GetMetrics(context.Context, *GetMetricsOpts) (*GenericResponse, error)
}

func RegisterControllerServer(s *grpc.Server, srv ControllerServer) {
	s.RegisterService(&_Controller_serviceDesc, srv)
}

func _Controller_CreateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CreateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/CreateVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CreateVolume(ctx, req.(*CreateVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_DeleteVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).DeleteVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/DeleteVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).DeleteVolume(ctx, req.(*DeleteVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ExtendVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtendVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ExtendVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/ExtendVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ExtendVolume(ctx, req.(*ExtendVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_CreateVolumeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeSnapshotOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CreateVolumeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/CreateVolumeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CreateVolumeSnapshot(ctx, req.(*CreateVolumeSnapshotOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_DeleteVolumeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeSnapshotOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).DeleteVolumeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/DeleteVolumeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).DeleteVolumeSnapshot(ctx, req.(*DeleteVolumeSnapshotOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_CreateVolumeAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeAttachmentOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CreateVolumeAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/CreateVolumeAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CreateVolumeAttachment(ctx, req.(*CreateVolumeAttachmentOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_DeleteVolumeAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeAttachmentOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).DeleteVolumeAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/DeleteVolumeAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).DeleteVolumeAttachment(ctx, req.(*DeleteVolumeAttachmentOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_CreateReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CreateReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/CreateReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CreateReplication(ctx, req.(*CreateReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_DeleteReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).DeleteReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/DeleteReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).DeleteReplication(ctx, req.(*DeleteReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_EnableReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).EnableReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/EnableReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).EnableReplication(ctx, req.(*EnableReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_DisableReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).DisableReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/DisableReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).DisableReplication(ctx, req.(*DisableReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_FailoverReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailoverReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).FailoverReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/FailoverReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).FailoverReplication(ctx, req.(*FailoverReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_CreateVolumeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeGroupOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CreateVolumeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/CreateVolumeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CreateVolumeGroup(ctx, req.(*CreateVolumeGroupOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_UpdateVolumeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVolumeGroupOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).UpdateVolumeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/UpdateVolumeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).UpdateVolumeGroup(ctx, req.(*UpdateVolumeGroupOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_DeleteVolumeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeGroupOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).DeleteVolumeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/DeleteVolumeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).DeleteVolumeGroup(ctx, req.(*DeleteVolumeGroupOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_GetMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetricsOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).GetMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Controller/GetMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).GetMetrics(ctx, req.(*GetMetricsOpts))
	}
	return interceptor(ctx, in, info, handler)
}

var _Controller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Controller",
	HandlerType: (*ControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolume",
			Handler:    _Controller_CreateVolume_Handler,
		},
		{
			MethodName: "DeleteVolume",
			Handler:    _Controller_DeleteVolume_Handler,
		},
		{
			MethodName: "ExtendVolume",
			Handler:    _Controller_ExtendVolume_Handler,
		},
		{
			MethodName: "CreateVolumeSnapshot",
			Handler:    _Controller_CreateVolumeSnapshot_Handler,
		},
		{
			MethodName: "DeleteVolumeSnapshot",
			Handler:    _Controller_DeleteVolumeSnapshot_Handler,
		},
		{
			MethodName: "CreateVolumeAttachment",
			Handler:    _Controller_CreateVolumeAttachment_Handler,
		},
		{
			MethodName: "DeleteVolumeAttachment",
			Handler:    _Controller_DeleteVolumeAttachment_Handler,
		},
		{
			MethodName: "CreateReplication",
			Handler:    _Controller_CreateReplication_Handler,
		},
		{
			MethodName: "DeleteReplication",
			Handler:    _Controller_DeleteReplication_Handler,
		},
		{
			MethodName: "EnableReplication",
			Handler:    _Controller_EnableReplication_Handler,
		},
		{
			MethodName: "DisableReplication",
			Handler:    _Controller_DisableReplication_Handler,
		},
		{
			MethodName: "FailoverReplication",
			Handler:    _Controller_FailoverReplication_Handler,
		},
		{
			MethodName: "CreateVolumeGroup",
			Handler:    _Controller_CreateVolumeGroup_Handler,
		},
		{
			MethodName: "UpdateVolumeGroup",
			Handler:    _Controller_UpdateVolumeGroup_Handler,
		},
		{
			MethodName: "DeleteVolumeGroup",
			Handler:    _Controller_DeleteVolumeGroup_Handler,
		},
		{
			MethodName: "GetMetrics",
			Handler:    _Controller_GetMetrics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model.proto",
}

// Client API for ProvisionDock service

type ProvisionDockClient interface {
	// Create a volume
	CreateVolume(ctx context.Context, in *CreateVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume
	DeleteVolume(ctx context.Context, in *DeleteVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Extend a volume
	ExtendVolume(ctx context.Context, in *ExtendVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume snapshot
	CreateVolumeSnapshot(ctx context.Context, in *CreateVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume snapshot
	DeleteVolumeSnapshot(ctx context.Context, in *DeleteVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume attachment
	CreateVolumeAttachment(ctx context.Context, in *CreateVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a volume attachment
	DeleteVolumeAttachment(ctx context.Context, in *DeleteVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a replication
	CreateReplication(ctx context.Context, in *CreateReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete a replication
	DeleteReplication(ctx context.Context, in *DeleteReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Enable a replication
	EnableReplication(ctx context.Context, in *EnableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Disable a replication
	DisableReplication(ctx context.Context, in *DisableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Failover a replication
	FailoverReplication(ctx context.Context, in *FailoverReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Create a volume group
	CreateVolumeGroup(ctx context.Context, in *CreateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Update volume group
	UpdateVolumeGroup(ctx context.Context, in *UpdateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Delete volume group
	DeleteVolumeGroup(ctx context.Context, in *DeleteVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error)
}

type provisionDockClient struct {
	cc *grpc.ClientConn
}

func NewProvisionDockClient(cc *grpc.ClientConn) ProvisionDockClient {
	return &provisionDockClient{cc}
}

func (c *provisionDockClient) CreateVolume(ctx context.Context, in *CreateVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/CreateVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) DeleteVolume(ctx context.Context, in *DeleteVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/DeleteVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) ExtendVolume(ctx context.Context, in *ExtendVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/ExtendVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) CreateVolumeSnapshot(ctx context.Context, in *CreateVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/CreateVolumeSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) DeleteVolumeSnapshot(ctx context.Context, in *DeleteVolumeSnapshotOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/DeleteVolumeSnapshot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) CreateVolumeAttachment(ctx context.Context, in *CreateVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/CreateVolumeAttachment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) DeleteVolumeAttachment(ctx context.Context, in *DeleteVolumeAttachmentOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/DeleteVolumeAttachment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) CreateReplication(ctx context.Context, in *CreateReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/CreateReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) DeleteReplication(ctx context.Context, in *DeleteReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/DeleteReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) EnableReplication(ctx context.Context, in *EnableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/EnableReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) DisableReplication(ctx context.Context, in *DisableReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/DisableReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) FailoverReplication(ctx context.Context, in *FailoverReplicationOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/FailoverReplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) CreateVolumeGroup(ctx context.Context, in *CreateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/CreateVolumeGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) UpdateVolumeGroup(ctx context.Context, in *UpdateVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/UpdateVolumeGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *provisionDockClient) DeleteVolumeGroup(ctx context.Context, in *DeleteVolumeGroupOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.ProvisionDock/DeleteVolumeGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ProvisionDock service

type ProvisionDockServer interface {
	// Create a volume
	CreateVolume(context.Context, *CreateVolumeOpts) (*GenericResponse, error)
	// Delete a volume
	DeleteVolume(context.Context, *DeleteVolumeOpts) (*GenericResponse, error)
	// Extend a volume
	ExtendVolume(context.Context, *ExtendVolumeOpts) (*GenericResponse, error)
	// Create a volume snapshot
	CreateVolumeSnapshot(context.Context, *CreateVolumeSnapshotOpts) (*GenericResponse, error)
	// Delete a volume snapshot
	DeleteVolumeSnapshot(context.Context, *DeleteVolumeSnapshotOpts) (*GenericResponse, error)
	// Create a volume attachment
	CreateVolumeAttachment(context.Context, *CreateVolumeAttachmentOpts) (*GenericResponse, error)
	// Delete a volume attachment
	DeleteVolumeAttachment(context.Context, *DeleteVolumeAttachmentOpts) (*GenericResponse, error)
	// Create a replication
	CreateReplication(context.Context, *CreateReplicationOpts) (*GenericResponse, error)
	// Delete a replication
	DeleteReplication(context.Context, *DeleteReplicationOpts) (*GenericResponse, error)
	// Enable a replication
	EnableReplication(context.Context, *EnableReplicationOpts) (*GenericResponse, error)
	// Disable a replication
	DisableReplication(context.Context, *DisableReplicationOpts) (*GenericResponse, error)
	// Failover a replication
	FailoverReplication(context.Context, *FailoverReplicationOpts) (*GenericResponse, error)
	// Create a volume group
	CreateVolumeGroup(context.Context, *CreateVolumeGroupOpts) (*GenericResponse, error)
	// Update volume group
	UpdateVolumeGroup(context.Context, *UpdateVolumeGroupOpts) (*GenericResponse, error)
	// Delete volume group
	DeleteVolumeGroup(context.Context, *DeleteVolumeGroupOpts) (*GenericResponse, error)
}

func RegisterProvisionDockServer(s *grpc.Server, srv ProvisionDockServer) {
	s.RegisterService(&_ProvisionDock_serviceDesc, srv)
}

func _ProvisionDock_CreateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).CreateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/CreateVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).CreateVolume(ctx, req.(*CreateVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_DeleteVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).DeleteVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/DeleteVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).DeleteVolume(ctx, req.(*DeleteVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_ExtendVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtendVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).ExtendVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/ExtendVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).ExtendVolume(ctx, req.(*ExtendVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_CreateVolumeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeSnapshotOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).CreateVolumeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/CreateVolumeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).CreateVolumeSnapshot(ctx, req.(*CreateVolumeSnapshotOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_DeleteVolumeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeSnapshotOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).DeleteVolumeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/DeleteVolumeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).DeleteVolumeSnapshot(ctx, req.(*DeleteVolumeSnapshotOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_CreateVolumeAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeAttachmentOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).CreateVolumeAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/CreateVolumeAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).CreateVolumeAttachment(ctx, req.(*CreateVolumeAttachmentOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_DeleteVolumeAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeAttachmentOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).DeleteVolumeAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/DeleteVolumeAttachment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).DeleteVolumeAttachment(ctx, req.(*DeleteVolumeAttachmentOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_CreateReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).CreateReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/CreateReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).CreateReplication(ctx, req.(*CreateReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_DeleteReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).DeleteReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/DeleteReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).DeleteReplication(ctx, req.(*DeleteReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_EnableReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).EnableReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/EnableReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).EnableReplication(ctx, req.(*EnableReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_DisableReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).DisableReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/DisableReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).DisableReplication(ctx, req.(*DisableReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_FailoverReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailoverReplicationOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).FailoverReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/FailoverReplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).FailoverReplication(ctx, req.(*FailoverReplicationOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_CreateVolumeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeGroupOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).CreateVolumeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/CreateVolumeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).CreateVolumeGroup(ctx, req.(*CreateVolumeGroupOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_UpdateVolumeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVolumeGroupOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).UpdateVolumeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/UpdateVolumeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).UpdateVolumeGroup(ctx, req.(*UpdateVolumeGroupOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProvisionDock_DeleteVolumeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVolumeGroupOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProvisionDockServer).DeleteVolumeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ProvisionDock/DeleteVolumeGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProvisionDockServer).DeleteVolumeGroup(ctx, req.(*DeleteVolumeGroupOpts))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProvisionDock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ProvisionDock",
	HandlerType: (*ProvisionDockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolume",
			Handler:    _ProvisionDock_CreateVolume_Handler,
		},
		{
			MethodName: "DeleteVolume",
			Handler:    _ProvisionDock_DeleteVolume_Handler,
		},
		{
			MethodName: "ExtendVolume",
			Handler:    _ProvisionDock_ExtendVolume_Handler,
		},
		{
			MethodName: "CreateVolumeSnapshot",
			Handler:    _ProvisionDock_CreateVolumeSnapshot_Handler,
		},
		{
			MethodName: "DeleteVolumeSnapshot",
			Handler:    _ProvisionDock_DeleteVolumeSnapshot_Handler,
		},
		{
			MethodName: "CreateVolumeAttachment",
			Handler:    _ProvisionDock_CreateVolumeAttachment_Handler,
		},
		{
			MethodName: "DeleteVolumeAttachment",
			Handler:    _ProvisionDock_DeleteVolumeAttachment_Handler,
		},
		{
			MethodName: "CreateReplication",
			Handler:    _ProvisionDock_CreateReplication_Handler,
		},
		{
			MethodName: "DeleteReplication",
			Handler:    _ProvisionDock_DeleteReplication_Handler,
		},
		{
			MethodName: "EnableReplication",
			Handler:    _ProvisionDock_EnableReplication_Handler,
		},
		{
			MethodName: "DisableReplication",
			Handler:    _ProvisionDock_DisableReplication_Handler,
		},
		{
			MethodName: "FailoverReplication",
			Handler:    _ProvisionDock_FailoverReplication_Handler,
		},
		{
			MethodName: "CreateVolumeGroup",
			Handler:    _ProvisionDock_CreateVolumeGroup_Handler,
		},
		{
			MethodName: "UpdateVolumeGroup",
			Handler:    _ProvisionDock_UpdateVolumeGroup_Handler,
		},
		{
			MethodName: "DeleteVolumeGroup",
			Handler:    _ProvisionDock_DeleteVolumeGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model.proto",
}

// Client API for AttachDock service

type AttachDockClient interface {
	// Attach a volume
	AttachVolume(ctx context.Context, in *AttachVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
	// Detach a volume
	DetachVolume(ctx context.Context, in *DetachVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error)
}

type attachDockClient struct {
	cc *grpc.ClientConn
}

func NewAttachDockClient(cc *grpc.ClientConn) AttachDockClient {
	return &attachDockClient{cc}
}

func (c *attachDockClient) AttachVolume(ctx context.Context, in *AttachVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.AttachDock/AttachVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attachDockClient) DetachVolume(ctx context.Context, in *DetachVolumeOpts, opts ...grpc.CallOption) (*GenericResponse, error) {
	out := new(GenericResponse)
	err := grpc.Invoke(ctx, "/proto.AttachDock/DetachVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AttachDock service

type AttachDockServer interface {
	// Attach a volume
	AttachVolume(context.Context, *AttachVolumeOpts) (*GenericResponse, error)
	// Detach a volume
	DetachVolume(context.Context, *DetachVolumeOpts) (*GenericResponse, error)
}

func RegisterAttachDockServer(s *grpc.Server, srv AttachDockServer) {
	s.RegisterService(&_AttachDock_serviceDesc, srv)
}

func _AttachDock_AttachVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachDockServer).AttachVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AttachDock/AttachVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachDockServer).AttachVolume(ctx, req.(*AttachVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttachDock_DetachVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachVolumeOpts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttachDockServer).DetachVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AttachDock/DetachVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttachDockServer).DetachVolume(ctx, req.(*DetachVolumeOpts))
	}
	return interceptor(ctx, in, info, handler)
}

var _AttachDock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AttachDock",
	HandlerType: (*AttachDockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AttachVolume",
			Handler:    _AttachDock_AttachVolume_Handler,
		},
		{
			MethodName: "DetachVolume",
			Handler:    _AttachDock_DetachVolume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "model.proto",
}

func init() { proto1.RegisterFile("model.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1931 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x49, 0x6f, 0x1b, 0x47,
	0x16, 0x36, 0x9b, 0xfb, 0xa3, 0x16, 0xaa, 0xb4, 0xb8, 0xc1, 0x91, 0x35, 0x32, 0xc7, 0x63, 0x08,
	0xb6, 0x47, 0x1e, 0x73, 0x06, 0xf0, 0x2c, 0xf0, 0xcc, 0x48, 0x96, 0x2c, 0x11, 0xb6, 0xc6, 0x32,
	0xbd, 0x1c, 0xe6, 0xd6, 0xee, 0x2e, 0x8f, 0x1a, 0x6a, 0x76, 0x31, 0xdd, 0x2d, 0xda, 0xca, 0x29,
	0x48, 0x72, 0x48, 0x7c, 0xcc, 0x31, 0xb7, 0x18, 0xc8, 0x2d, 0xf9, 0x09, 0x41, 0x7e, 0x45, 0x72,
	0x0c, 0x90, 0x63, 0x80, 0x9c, 0x73, 0x08, 0x72, 0x08, 0xba, 0x7a, 0x61, 0x55, 0x2f, 0xc5, 0x66,
	0xb4, 0x58, 0x86, 0x79, 0x22, 0xeb, 0x55, 0xf5, 0xeb, 0xf7, 0xbe, 0xf7, 0xde, 0x57, 0x4b, 0x17,
	0xd4, 0xba, 0x44, 0xc3, 0xc6, 0x6a, 0xcf, 0x22, 0x0e, 0x41, 0x45, 0xfa, 0xd3, 0x7c, 0x59, 0x82,
	0xfa, 0x6d, 0x0b, 0x2b, 0x0e, 0x7e, 0x42, 0x8c, 0x83, 0x2e, 0xbe, 0xdf, 0x73, 0x6c, 0x34, 0x05,
	0x92, 0xae, 0xc9, 0xb9, 0xe5, 0xdc, 0x4a, 0xb5, 0x23, 0xe9, 0x1a, 0x42, 0x50, 0x30, 0x95, 0x2e,
	0x96, 0x25, 0x2a, 0xa1, 0xff, 0x5d, 0x99, 0xad, 0xbf, 0x8b, 0xe5, 0xfc, 0x72, 0x6e, 0x25, 0xdf,
	0xa1, 0xff, 0xd1, 0x32, 0xd4, 0x34, 0x6c, 0xab, 0x96, 0xde, 0x73, 0x74, 0x62, 0xca, 0x05, 0x3a,
	0x9c, 0x15, 0xa1, 0x25, 0x00, 0xdb, 0x54, 0x7a, 0xf6, 0x1e, 0x71, 0xda, 0x9a, 0x5c, 0xa4, 0x03,
	0x18, 0x09, 0xba, 0x02, 0x75, 0xa5, 0xaf, 0xe8, 0x86, 0xf2, 0x54, 0x37, 0x74, 0xe7, 0xf0, 0x7f,
	0xc4, 0xc4, 0x72, 0x89, 0x8e, 0x8a, 0xc9, 0xd1, 0x22, 0x54, 0x7b, 0x16, 0x79, 0xa6, 0x1b, 0xb8,
	0xad, 0xc9, 0x65, 0x3a, 0x68, 0x20, 0x40, 0x0b, 0x50, 0xea, 0x11, 0x62, 0xb4, 0x35, 0xb9, 0x42,
	0xbb, 0xfc, 0x16, 0x6a, 0x40, 0xc5, 0xfd, 0xf7, 0x5f, 0xd7, 0x9f, 0x2a, 0xed, 0x09, 0xdb, 0x68,
	0x0d, 0x2a, 0x5d, 0xec, 0x28, 0x9a, 0xe2, 0x28, 0x32, 0x2c, 0xe7, 0x57, 0x6a, 0xad, 0x3f, 0x7a,
	0x68, 0xad, 0x46, 0x21, 0x5a, 0xdd, 0xf1, 0xc7, 0x6d, 0x9a, 0x8e, 0x75, 0xd8, 0x09, 0x1f, 0x73,
	0x1d, 0xd4, 0x2c, 0xbd, 0x8f, 0x2d, 0xfa, 0x82, 0x9a, 0xe7, 0xe0, 0x40, 0x82, 0x64, 0x28, 0xab,
	0xc4, 0x74, 0xf0, 0x0b, 0x47, 0x9e, 0xa0, 0x9d, 0x41, 0x13, 0xed, 0xc1, 0xbc, 0x85, 0x7b, 0x86,
	0xae, 0x2a, 0x2e, 0x52, 0x1b, 0xf4, 0x91, 0x0d, 0xd7, 0x92, 0x49, 0x6a, 0x49, 0x2b, 0xcd, 0x92,
	0x4e, 0xd2, 0x43, 0x9e, 0x59, 0xc9, 0x0a, 0xd1, 0x25, 0x98, 0x64, 0x3a, 0xda, 0x9a, 0x3c, 0x45,
	0x2d, 0xe1, 0x85, 0xa8, 0x09, 0x13, 0x41, 0x60, 0x1e, 0xba, 0x81, 0x9e, 0xa6, 0x81, 0xe6, 0x64,
	0xe8, 0x1a, 0xcc, 0x04, 0xed, 0x3b, 0x16, 0xe9, 0xde, 0x36, 0xc8, 0x81, 0x26, 0xd7, 0x97, 0x73,
	0x2b, 0x95, 0x4e, 0xbc, 0xc3, 0xf5, 0xdd, 0x8f, 0x8f, 0x3c, 0xe3, 0xf9, 0xee, 0x37, 0x1b, 0xff,
	0x84, 0x49, 0x0e, 0x50, 0x54, 0x87, 0xfc, 0x3e, 0x3e, 0xf4, 0x53, 0xd0, 0xfd, 0x8b, 0xe6, 0xa0,
	0xd8, 0x57, 0x8c, 0x83, 0x20, 0x09, 0xbd, 0xc6, 0x3f, 0xa4, 0xbf, 0xe5, 0x1a, 0xdb, 0xd0, 0x48,
	0xc7, 0x60, 0x14, 0x4d, 0xcd, 0x2f, 0x24, 0xa8, 0x6f, 0x60, 0x03, 0x0b, 0x8b, 0x81, 0x4b, 0x3b,
	0x29, 0x3d, 0xed, 0xf2, 0x5c, 0xda, 0xb1, 0xa9, 0x55, 0xe0, 0x52, 0x2b, 0xfa, 0xc2, 0x8c, 0xa9,
	0x55, 0x14, 0xa5, 0x56, 0x89, 0x4f, 0x2d, 0x06, 0xf8, 0xf2, 0xf1, 0x01, 0xdf, 0xfc, 0x2e, 0x0f,
	0xf5, 0xcd, 0x17, 0x0e, 0x36, 0xb5, 0x31, 0x77, 0x08, 0xb8, 0x23, 0x0a, 0xd1, 0x09, 0x70, 0x07,
	0x13, 0xe0, 0xc9, 0x63, 0x0c, 0xf0, 0xcb, 0x3c, 0xc8, 0x2c, 0xdf, 0x3c, 0xf4, 0xc1, 0x3e, 0xe1,
	0x40, 0x37, 0xa0, 0xd2, 0xa7, 0xef, 0x0b, 0xc3, 0x1c, 0xb6, 0xf9, 0xc0, 0x95, 0xa2, 0x81, 0x6b,
	0x33, 0x41, 0x28, 0xd3, 0x20, 0xfc, 0x29, 0x81, 0x36, 0x59, 0x37, 0x32, 0x06, 0xa3, 0x22, 0x0a,
	0x46, 0x35, 0x35, 0x18, 0x70, 0x8c, 0xc1, 0x78, 0x25, 0x81, 0xcc, 0x72, 0x85, 0x30, 0x18, 0x2c,
	0x84, 0x52, 0x04, 0x42, 0x16, 0xa4, 0x3c, 0x07, 0x52, 0x9a, 0xfa, 0x8c, 0x20, 0x15, 0x44, 0x20,
	0x15, 0x53, 0x41, 0x2a, 0x1d, 0x23, 0x48, 0x9f, 0xe7, 0xa1, 0xc1, 0x86, 0x7a, 0xcd, 0x71, 0x14,
	0x75, 0xaf, 0x8b, 0xcd, 0xd1, 0x61, 0xba, 0x04, 0x93, 0x1a, 0xb9, 0x47, 0x54, 0xc5, 0xf0, 0x94,
	0xd0, 0x24, 0xae, 0x74, 0x78, 0xa1, 0x9b, 0x8f, 0xdd, 0x03, 0xc3, 0xd1, 0x77, 0x15, 0x67, 0x8f,
	0x02, 0x50, 0xe9, 0x0c, 0x04, 0xe8, 0x2a, 0x54, 0xf6, 0x88, 0xed, 0xb4, 0xcd, 0x67, 0x84, 0x02,
	0x50, 0x6b, 0x4d, 0xfb, 0x50, 0x6f, 0xfb, 0xe2, 0x4e, 0x38, 0x00, 0xdd, 0x65, 0xe2, 0x52, 0xa2,
	0x71, 0xb9, 0x9e, 0x90, 0xbc, 0xbc, 0x47, 0x19, 0x23, 0x53, 0x16, 0x45, 0xa6, 0xc2, 0x47, 0xe6,
	0x32, 0x4c, 0xad, 0xa9, 0x2a, 0xb6, 0xed, 0x5d, 0xf7, 0xdd, 0x2a, 0x31, 0xfc, 0xfc, 0x8e, 0x48,
	0x8f, 0x16, 0xa7, 0xef, 0x25, 0x68, 0xb0, 0xd9, 0x76, 0x84, 0x38, 0xb1, 0x18, 0xe7, 0x47, 0xc1,
	0xb8, 0xc0, 0x61, 0x9c, 0x6e, 0xcd, 0x09, 0x4c, 0xc8, 0x71, 0x8c, 0xcb, 0xc7, 0x8f, 0xf1, 0x97,
	0x79, 0x58, 0xf4, 0x32, 0x27, 0xa8, 0xe5, 0x21, 0x28, 0xf3, 0x13, 0xac, 0x14, 0x9b, 0x60, 0x4f,
	0xbd, 0x22, 0x76, 0x62, 0x15, 0x71, 0x83, 0xab, 0x88, 0x64, 0xbf, 0xde, 0xd4, 0x9a, 0xf8, 0x41,
	0x82, 0x45, 0x2f, 0x0b, 0x8f, 0x29, 0x5e, 0x23, 0x55, 0xc6, 0x4e, 0xac, 0x32, 0x6e, 0x70, 0x95,
	0x71, 0x24, 0xac, 0xcf, 0x5c, 0x6d, 0xbc, 0x97, 0x83, 0x4a, 0x00, 0x02, 0x5d, 0xd6, 0x19, 0x8a,
	0xf3, 0x8c, 0x58, 0x5d, 0xff, 0xe9, 0xb0, 0xed, 0x2e, 0x05, 0x89, 0xfd, 0xe8, 0xb0, 0x17, 0xe8,
	0xf0, 0x5b, 0xee, 0xca, 0xc6, 0x85, 0xce, 0x5f, 0xe5, 0xd3, 0xff, 0x34, 0x3e, 0x3d, 0x7f, 0x16,
	0x94, 0xf4, 0x9e, 0x5b, 0x09, 0xba, 0xa9, 0x3b, 0xba, 0xe2, 0x10, 0xcb, 0x87, 0x60, 0x20, 0x68,
	0xf6, 0x01, 0x3c, 0xb6, 0xa1, 0x7b, 0xb2, 0xeb, 0x50, 0xa0, 0xd0, 0xe7, 0x28, 0xf4, 0xbf, 0xf3,
	0xa1, 0x1f, 0x0c, 0x58, 0x1d, 0xec, 0xea, 0xe8, 0xc0, 0xc6, 0x4d, 0xa8, 0xfe, 0xb6, 0x4d, 0xce,
	0x57, 0x55, 0x98, 0xf7, 0xca, 0x87, 0xd9, 0x35, 0x65, 0x5e, 0xd1, 0x45, 0x56, 0x6f, 0xf9, 0xf8,
	0xea, 0x6d, 0x05, 0xa6, 0x7b, 0x96, 0xde, 0x55, 0xac, 0xc3, 0x27, 0x01, 0x65, 0x7b, 0x90, 0x44,
	0xc5, 0x74, 0xf7, 0x88, 0x55, 0x62, 0x6a, 0xec, 0x58, 0x0f, 0xa7, 0x78, 0xc7, 0x6b, 0x5e, 0xde,
	0xbf, 0x9f, 0x83, 0x45, 0xdf, 0xfe, 0xc4, 0xcd, 0xa6, 0x5c, 0xa3, 0x81, 0xfb, 0x17, 0xc7, 0x4f,
	0x11, 0x80, 0x57, 0x77, 0x05, 0x0a, 0xbc, 0xd8, 0x0a, 0xdf, 0x81, 0x3e, 0xca, 0xc1, 0x52, 0x08,
	0x4c, 0xb2, 0x19, 0x13, 0xd4, 0x8c, 0xff, 0x08, 0xcd, 0x78, 0x28, 0x54, 0xe1, 0x19, 0x32, 0xe4,
	0x3d, 0x2e, 0x86, 0x1a, 0x51, 0xf7, 0xdb, 0x9a, 0xbf, 0xe1, 0xf0, 0x5b, 0x91, 0xba, 0x9f, 0x12,
	0xd5, 0xfd, 0x34, 0x5f, 0xf7, 0x6e, 0xb5, 0xd8, 0x3e, 0x42, 0xfe, 0x19, 0xc2, 0x40, 0x80, 0xee,
	0x30, 0xf4, 0x34, 0x43, 0x7d, 0xbc, 0x22, 0xf4, 0x31, 0x8d, 0x97, 0xfe, 0x0e, 0x53, 0xfd, 0xb0,
	0xa8, 0xee, 0xe9, 0xb6, 0x23, 0x23, 0xaa, 0x6d, 0x26, 0x56, 0x71, 0x9d, 0xc8, 0x40, 0x37, 0xb1,
	0x99, 0x13, 0x92, 0x1d, 0xa2, 0x61, 0x79, 0xd6, 0x4b, 0xec, 0x88, 0xd8, 0x4d, 0x6c, 0xc6, 0x9e,
	0x5d, 0x6c, 0xe9, 0x44, 0x93, 0xe7, 0xe8, 0x1e, 0x28, 0xde, 0x81, 0x5a, 0x30, 0xc7, 0x08, 0xd7,
	0x15, 0x53, 0x7b, 0xae, 0x6b, 0xce, 0x9e, 0x3c, 0x4f, 0x1f, 0x48, 0xec, 0x63, 0x97, 0xcf, 0x0b,
	0xfc, 0xf2, 0xf9, 0x3e, 0x5c, 0x1c, 0x9a, 0x66, 0x23, 0x1d, 0xaf, 0x3c, 0x80, 0x3f, 0x64, 0x48,
	0x98, 0x91, 0x54, 0x1e, 0x89, 0xba, 0x7f, 0x2a, 0xc3, 0xbc, 0x37, 0x25, 0x8d, 0xf9, 0xeb, 0xc4,
	0xf8, 0x2b, 0x11, 0xe0, 0xd3, 0xe7, 0xaf, 0x64, 0x33, 0xce, 0x26, 0x7f, 0xb1, 0x0c, 0x55, 0xe7,
	0x18, 0x2a, 0xd9, 0x8b, 0x34, 0x86, 0xe2, 0x78, 0x70, 0x26, 0xca, 0x83, 0x4c, 0xe1, 0xa3, 0xb7,
	0xb0, 0xf0, 0x37, 0x4d, 0xe5, 0xa9, 0x31, 0x2e, 0xfc, 0x93, 0x2b, 0xfc, 0x44, 0x80, 0x4f, 0xbf,
	0xf0, 0x93, 0xcd, 0x78, 0xd3, 0x0a, 0x3f, 0xd9, 0x8b, 0x71, 0xe1, 0x8f, 0x58, 0xf8, 0x3f, 0x97,
	0x61, 0x61, 0x43, 0xb7, 0xc7, 0x95, 0x3f, 0x5a, 0xe5, 0x7f, 0x90, 0xad, 0xf2, 0xff, 0x1d, 0xcc,
	0x52, 0x89, 0x08, 0x1f, 0xb9, 0xf4, 0x3f, 0xce, 0x5a, 0xfa, 0x6b, 0x62, 0x3b, 0xce, 0x66, 0xed,
	0x6f, 0xc5, 0x6a, 0xff, 0xaa, 0xd8, 0x8d, 0x71, 0xf1, 0x8f, 0x58, 0xfc, 0xdf, 0x54, 0xe1, 0xfc,
	0x1d, 0x45, 0x37, 0x48, 0x1f, 0x5b, 0xe3, 0xea, 0xcf, 0x5e, 0xfd, 0x1f, 0x66, 0xab, 0xfe, 0x60,
	0xc2, 0x4d, 0x81, 0xf8, 0xc8, 0xe5, 0xff, 0x32, 0x6b, 0xf9, 0xaf, 0x0f, 0x31, 0xe4, 0x6c, 0xd6,
	0xff, 0x9f, 0x61, 0x56, 0x31, 0x0c, 0xf2, 0xdc, 0x3b, 0x15, 0xc5, 0xfe, 0x57, 0x5e, 0xff, 0xf8,
	0x22, 0xa9, 0x0b, 0xad, 0x02, 0x0a, 0xad, 0x5c, 0x57, 0xd4, 0x7d, 0x6c, 0x6a, 0x6d, 0xcd, 0xbf,
	0x0f, 0x91, 0xd0, 0x83, 0xb6, 0x19, 0x86, 0xf1, 0x8e, 0x2a, 0xae, 0x0d, 0x41, 0x2a, 0x13, 0xc5,
	0xcc, 0x0a, 0x28, 0x66, 0xee, 0xed, 0xa2, 0x98, 0x86, 0x0d, 0xd3, 0x03, 0x2c, 0xdf, 0x39, 0xc0,
	0x76, 0x6a, 0x5c, 0x73, 0xa3, 0xc6, 0x55, 0x4a, 0x8b, 0x6b, 0xf3, 0x33, 0x29, 0x38, 0x86, 0xf5,
	0x14, 0x6c, 0x59, 0xe4, 0xa0, 0x97, 0x99, 0xd5, 0xf8, 0x8c, 0xcd, 0xc7, 0x32, 0x76, 0xf8, 0x47,
	0xf6, 0x24, 0x76, 0x2a, 0xa6, 0xb0, 0xd3, 0x12, 0x80, 0xa2, 0xf9, 0x8e, 0xda, 0xf4, 0x4b, 0x4c,
	0xb5, 0xc3, 0x48, 0xbc, 0x0b, 0x45, 0x5d, 0xd2, 0xc7, 0xc1, 0x90, 0x32, 0x1d, 0xc2, 0x0b, 0x53,
	0x59, 0x2c, 0xf5, 0x4b, 0x7a, 0xf3, 0xeb, 0x1c, 0xcc, 0x3f, 0xee, 0x69, 0x19, 0x30, 0xe2, 0xf1,
	0x90, 0x62, 0x78, 0xf0, 0x1e, 0xe4, 0x87, 0x7b, 0x50, 0x10, 0x7b, 0x50, 0x4c, 0xf3, 0x80, 0xff,
	0x98, 0xd1, 0x3c, 0x0c, 0xce, 0xaa, 0x86, 0x39, 0x30, 0x50, 0x2d, 0x71, 0xaa, 0x87, 0x05, 0x9a,
	0x79, 0x75, 0x81, 0x7f, 0xf5, 0x2f, 0x39, 0xa8, 0x7b, 0x39, 0xca, 0xdc, 0xce, 0xb9, 0x0c, 0x53,
	0x0a, 0xff, 0x71, 0xc5, 0x33, 0x21, 0x22, 0x75, 0xc7, 0xa9, 0xc4, 0x34, 0xb1, 0x4a, 0x0b, 0xd3,
	0xe5, 0x1e, 0xcf, 0xac, 0x88, 0x94, 0xbb, 0xf5, 0x92, 0xe7, 0x6e, 0xbd, 0x44, 0x5f, 0x9d, 0x4a,
	0x4b, 0xa9, 0x1e, 0x1c, 0x6d, 0xdd, 0xe0, 0xba, 0xbf, 0x81, 0x5f, 0x9b, 0xfb, 0xd1, 0x57, 0x9f,
	0xb6, 0xfb, 0x3f, 0xe6, 0x60, 0x7a, 0x0b, 0x9b, 0xd8, 0xd2, 0xd5, 0x0e, 0xb6, 0x7b, 0xc4, 0xb4,
	0x31, 0xba, 0x09, 0x25, 0x0b, 0xdb, 0x07, 0x86, 0x43, 0x55, 0xd4, 0x5a, 0x17, 0x7c, 0x5b, 0x23,
	0xe3, 0x56, 0x3b, 0x74, 0xd0, 0xf6, 0xb9, 0x8e, 0x3f, 0x1c, 0xfd, 0x15, 0x8a, 0xd8, 0xb2, 0x88,
	0x45, 0x5f, 0x53, 0x6b, 0x2d, 0xa6, 0x3c, 0xb7, 0xe9, 0x8e, 0xd9, 0x3e, 0xd7, 0xf1, 0x06, 0x37,
	0x9a, 0x50, 0xf2, 0x34, 0xb9, 0x3e, 0x76, 0xb1, 0x6d, 0x2b, 0xff, 0xc7, 0xbe, 0xf1, 0x41, 0xb3,
	0x71, 0x0b, 0x8a, 0xf4, 0x29, 0x97, 0xe4, 0x54, 0xa2, 0x05, 0xfd, 0xf4, 0x7f, 0x94, 0xc4, 0xa4,
	0x18, 0x89, 0xad, 0x97, 0xa1, 0x68, 0xe1, 0x9e, 0x71, 0xd8, 0x7c, 0x95, 0x83, 0xa9, 0x2d, 0xec,
	0xec, 0x60, 0xc7, 0xd2, 0x55, 0x9b, 0xc6, 0x7a, 0x09, 0x40, 0x37, 0x6d, 0x47, 0x31, 0x55, 0x77,
	0x4d, 0xe5, 0xe9, 0x65, 0x24, 0x6e, 0x7f, 0x97, 0x0e, 0x67, 0x29, 0x63, 0x20, 0x71, 0xa7, 0x4b,
	0xdb, 0x51, 0x2c, 0xe7, 0x91, 0x1e, 0x16, 0xde, 0x40, 0xe0, 0xba, 0x84, 0x4d, 0x8d, 0xf6, 0xf9,
	0x61, 0xf3, 0x9b, 0xe9, 0x77, 0x5e, 0x5a, 0xdf, 0x56, 0x01, 0x6e, 0x13, 0xd3, 0xb1, 0x88, 0x61,
	0x60, 0x0b, 0xad, 0xc1, 0x04, 0x3b, 0x01, 0xa0, 0xf3, 0x29, 0x37, 0x3c, 0x1b, 0x0b, 0xc9, 0x78,
	0x37, 0xcf, 0xb9, 0x2a, 0x58, 0x7a, 0x09, 0x55, 0x44, 0xef, 0x14, 0x8a, 0x55, 0xb0, 0x17, 0xd4,
	0x42, 0x15, 0xd1, 0x5b, 0x6b, 0x02, 0x15, 0x0f, 0x60, 0x2e, 0xe9, 0x7a, 0x15, 0xfa, 0xfd, 0x90,
	0xbb, 0x57, 0x62, 0x95, 0x49, 0x97, 0x91, 0x42, 0x95, 0x69, 0x37, 0x95, 0x04, 0x2a, 0x1f, 0xc3,
	0x42, 0xf2, 0x3d, 0x1a, 0x74, 0x71, 0xe8, 0x35, 0x1b, 0xb1, 0xda, 0xe4, 0xab, 0x23, 0xa1, 0xda,
	0xf4, 0x9b, 0x25, 0x02, 0xb5, 0x77, 0x61, 0x26, 0xf6, 0x61, 0x0b, 0x2d, 0x8a, 0x3e, 0x79, 0x89,
	0x95, 0xc5, 0xce, 0xa0, 0x43, 0x65, 0x89, 0xa7, 0xd3, 0x62, 0x65, 0xb1, 0x73, 0xad, 0x50, 0x59,
	0xe2, 0x89, 0x97, 0x40, 0xd9, 0x0e, 0xa0, 0xf8, 0x46, 0x19, 0x5d, 0x10, 0xee, 0xa1, 0x05, 0xea,
	0xee, 0xc3, 0x6c, 0xc2, 0xaa, 0x18, 0x2d, 0x89, 0x57, 0xcc, 0x59, 0xc2, 0xc0, 0xcc, 0xdf, 0x91,
	0x30, 0x44, 0x66, 0x76, 0xb1, 0xb2, 0xd8, 0x6a, 0x26, 0x54, 0x96, 0xb8, 0xce, 0xc9, 0x12, 0xd3,
	0x24, 0x65, 0x89, 0x6b, 0x0e, 0x81, 0xb2, 0x5b, 0x00, 0x03, 0xf6, 0x44, 0xf3, 0xe1, 0x38, 0x96,
	0x50, 0xd3, 0x1f, 0x6f, 0x7d, 0x5a, 0x85, 0xc9, 0x5d, 0x8b, 0xf4, 0x75, 0xdb, 0x9d, 0x18, 0x89,
	0xba, 0x3f, 0xe6, 0xb6, 0x31, 0xb7, 0x8d, 0xb9, 0x6d, 0xcc, 0x6d, 0x67, 0x80, 0xdb, 0x5a, 0x9f,
	0xe4, 0x00, 0xbc, 0xd4, 0x0c, 0x98, 0x89, 0xdd, 0x9a, 0x84, 0x9c, 0x10, 0xdd, 0xaf, 0x0c, 0x63,
	0xa6, 0x04, 0x15, 0xd1, 0x35, 0x7f, 0xba, 0x8a, 0xa7, 0x25, 0xda, 0xf1, 0x97, 0x5f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x19, 0x29, 0x77, 0x97, 0x93, 0x35, 0x00, 0x00,
}
