// Copyright (c) 2016 Huawei Technologies Co., Ltd. All Rights Reserved.
//
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License. You may obtain
//    a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
//    License for the specific language governing permissions and limitations
//    under the License.

/*
This module implements CoprHD plugin for OpenSDS. CoprHD plugin will pass these
operation requests about volume to REST API.

*/

package coprHD

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"net/url"

	"gopkg.in/jmcvetta/napping.v3"

	"github.com/libopenstorage/openstorage/api"
)

const (
	Name = "coprhd"
	Type = api.DriverType_DRIVER_TYPE_BLOCK

	// LoginUri path to create a authentication token
	loginUri = "login.json"
	// LoginUri path to create volume
	createVolumeUri = "block/volumes.json"
)

// ApiError represents the default api error code
type ApiError struct {
	Code        string `json:"code"`
	Retryable   string `json:"retryable"`
	Description string `json:"description"`
	Details     string `json:"details"`
}

// CreateVolumeArgs represents the json parameters for the create volume REST call
type CreateVolumeArgs struct {
	ConsistencyGroup string `json:"consistency_group"`
	Count            int    `json:"count"`
	Name             string `json:"name"`
	Project          string `json:"project"`
	Size             string `json:"size"`
	VArray           string `json:"varray"`
	VPool            string `json:"vpool"`
}

// CreateVolumeReply is the reply from the create volume REST call
type CreateVolumeReply struct {
	Task []struct {
		Resource struct {
			Name string `json:"name"`
			Id   string `json:"id"`
		} `json:"resource"`
	} `json:"task"`
}

type driver struct {
	// volume.IODriver
	// volume.StoreEnumerator
	consistency_group string
	project           string
	varray            string
	vpool             string
	url               string
	httpClient        *http.Client
	creds             *url.Userinfo
}

func Init(params map[string]string) (volume.VolumeDriver, error) {
	restUrl, ok := params["restUrl"]
	if !ok {
		return nil, fmt.Errorf("rest api 'url' configuration parameter must be set")
	}

	user, ok := params["user"]
	if !ok {
		return nil, fmt.Errorf("rest auth 'user' must be set")
	}

	pass, ok := params["password"]
	if !ok {
		return nil, fmt.Errorf("rest auth 'password' must be set")
	}

	consistency_group, ok := params["consistency_group"]
	if !ok {
		return nil, fmt.Errorf("'consistency_group' configuration parameter must be set")
	}

	project, ok := params["project"]
	if !ok {
		return nil, fmt.Errorf("'project' configuration parameter must be set")
	}

	varray, ok := params["varray"]
	if !ok {
		return nil, fmt.Errorf("'varray' configuration parameter must be set")
	}

	vpool, ok := params["vpool"]
	if !ok {
		return nil, fmt.Errorf("'vpool' configuration parameter must be set")
	}

	d := &driver{
		// IODriver:          volume.IONotSupported,
		// StoreEnumerator:   common.NewDefaultStoreEnumerator(Name, kvdb.Instance()),
		consistency_group: consistency_group,
		project:           project,
		varray:            varray,
		vpool:             vpool,
		url:               restUrl,
		creds:             url.UserPassword(user, pass),
		httpClient: &http.Client{
			Transport: &http.Transport{
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
			},
		},
	}

	return d, nil
}

func (d *driver) Name() string {
	return Name
}

func (d *driver) Type() api.DriverType {
	return Type
}

func (d *driver) Create(
	locator *api.VolumeLocator,
	source *api.Source,
	spec *api.VolumeSpec,
) (string, error) {

	s, err := d.getAuthSession()

	if err != nil {
		err = fmt.Sprintf("Failed to create session: %s", err.Error())
		return "", err
	}

	e := ApiError{}

	res := &CreateVolumeReply{}

	sz := int64(spec.Size / (1024 * 1024 * 1000))

	payload := CreateVolumeArgs{
		d.consistency_group,       // ConsistencyGroup
		1,                         // Count
		locator.Name,              // Name
		d.project,                 // Project
		fmt.Sprintf("%.6fGB", sz), // Volume Size
		d.varray,                  // Virtual Block Array
		d.vpool,                   // Virtual Block Pool
	}

	url := d.url + createVolumeUri

	resp, err := s.Post(url, &payload, res, &e)

	if resp.Status() != http.StatusAccepted {

		return "", fmt.Errorf("Failed to create volume: %s", resp.Status())
	}

	return res.Task[0].Resource.Id, err
}

func (d *driver) Delete(volumeID string) error {
	return nil
}

func (d *driver) Stats(volumeID string, cumulative bool) (*api.Stats, error) {
	return nil, volume.ErrNotSupported
}

func (d *driver) Alerts(volumeID string) (*api.Alerts, error) {
	return nil, volume.ErrNotSupported
}

func (d *driver) Attach(volumeID string) (path string, err error) {
	return "", nil
}

func (d *driver) MountedAt(mountpath string) string {
	return ""
}

func (d *driver) Detach(volumeID string) error {
	return nil
}

func (d *driver) Mount(volumeID string, mountpath string) error {
	return nil
}

func (d *driver) Unmount(volumeID string, mountpath string) error {

	return nil
}

func (d *driver) Set(
	volumeID string,
	locator *api.VolumeLocator,
	spec *api.VolumeSpec) error {
	return volume.ErrNotSupported
}

func (d *driver) Shutdown() {
	fmt.Printf("%s Shutting down", Name)
}

func (d *driver) Snapshot(
	volumeID string,
	readonly bool,
	locator *api.VolumeLocator) (string, error) {
	return "", nil
}

func (v *driver) Status() [][2]string {
	return [][2]string{}
}

// getAuthSession returns an authenticated API Session
func (d *driver) getAuthSession() (session *napping.Session, err error) {
	e := ApiError{}

	s := napping.Session{
		Userinfo: d.creds,
		Client:   d.httpClient,
	}

	url := d.url + loginUri

	resp, err := s.Get(url, nil, nil, &e)

	if err != nil {
		return
	}

	token := resp.HttpResponse().Header.Get("X-SDS-AUTH-TOKEN")

	h := http.Header{}

	h.Set("X-SDS-AUTH-TOKEN", token)

	session = &napping.Session{
		Client: d.httpClient,
		Header: &h,
	}

	return
}

func (d *driver) GetActiveRequests() (*api.ActiveRequests, error) {
	return nil, nil
}
